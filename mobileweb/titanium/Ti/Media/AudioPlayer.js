define(['Ti/_/declare', 'Ti/_/dom', 'Ti/_/event', 'Ti/_/lang', 'Ti/_/Evented'],
	function(declare, dom, event, lang, Evented) {
	
	// Ti.Media.AudioPlayer is based on tag <audio> of HTML5.
	//
	// Unlike Ti.Media.Sound, it is suited best for playing non-local files (streams)
	// from the Internet. Although the implementation is similar to Ti.Media.Sound,
	// the interface is different, including callbacks. (For example, unlike Sound,
	// error reporting is lacking in the interface of AudioPlayer.)
	//
	// Ti.Media.AudioPlayer wraps the interface of the <audio> tag, adds basic
	// state management, error checking, and provides interface common for
	// Titanium namespaces.
	
	var on = require.on,
		mimeTypes = {
			'mp3': 'audio/mpeg',
			'ogg': 'audio/ogg',
			'wav': 'audio/wav'
		},
		urlRegExp = /.+\.([^\/\.]+?)$/,
		messageMap = [void 0, 'Aborted', 'Decode error', 'Network error', 'Unsupported format'],
		stateMap = ['buffering', 'initialized', 'paused', 'playing', 'starting',
					'stopped', 'stopping','waiting for data', 'waiting for queue'],
		BUFFERING = 0,
		INITIALIZED = 1,
		PAUSED = 2,
		PLAYING = 3,
		STARTING = 4,
		STOPPED = 5,
		STOPPING = 6,
		WAITING_FOR_DATA = 7,
		WAITING_FOR_QUEUE = 8,
		ENDED = 9,
		ABORT = 10,
		ERROR = 11;
			
	return declare('Ti.Media.AudioPlayer', Evented, {
		
		constructor: function() {
			this._handles = [];
		},
		
		_currentState: STOPPED,
				
		// Update the state information;
		// fire external events according to changes of the internal state.
		_changeState: function(newState, description) {
			var cons = this.constants.__values__,
				evt = {};
			
			cons.playing = PLAYING === newState;
			cons.paused  = PAUSED === newState;
			cons.idle = this._initialized && !cons.playing;
			
			evt.state = cons.state = this._currentState = newState;
			evt.src = this;
			evt.description = description;
			
			this.fireEvent('change', evt);// external (interface) event
		},
		
		_createAudio: function(url) {
			var self = this,
				progress = self.constants.__values__.progress,
				audio = self._audio = dom.create('audio'),
				i = 0, attr, match;
			
			// Handlers of events generated by the <audio> tag. 
			// These events are handled here and do not propagate outside.
			self._handles = [
				on(audio, 'playing', self, function() {
					self._changeState(PLAYING, 'playing');
				}),
				on(audio, 'play', self, function() {
					self._changeState(STARTING, 'starting');
				}),
				on(audio, 'pause', self, function() {
					self._currentState === STOPPING ? self._stop() : self._changeState(PAUSED, 'paused');
				}),
				on(audio, 'ended', self, function() {
					// stopped with description='ended'
					self._stop('ended');
				}),
				on(audio, 'abort', self, function() {
					// stopped with description='abort'
					self._changeState(STOPPED, 'abort');
				}),
				on(audio, 'timeupdate', self, function() {
					progress = Math.floor(self._audio.currentTime * 1000);
					self.fireEvent( 'progress', { 'progress': progress } );// external (interface) event
					self._currentState === STOPPING && self.pause();
				}),
				on(audio, 'error', self, function() {
					// The error event is missing in Titanium API.
					// So we will fire 'change' event with state='STOPPED' 
					// and description about error
					self._changeState(STOPPED, 'error: ' + (messageMap[self._audio.error.code] || 'Unknown error'));
				}),
				on(audio, 'canplay', self, function() {
					self._initialized = 1;
					
					//Audio has just initialized
					self._audio.volume = self.volume;
					self._changeState(INITIALIZED, 'initialized');
					
					//autoplay or _nextCmd()
					if (self.autoplay || self._nextCmd === self.start) {
						audio.play();
					} else if ( self._nextCmd ) {
						self._nextCmd();
					}
					
					self._nextCmd = 0;
					self.autoplay = false;
				})
			];
			
			document.body.appendChild(audio);
			
			//Set 'url' into tag <source> of tag <audio>
			require.is(url, 'Array') || (url = [url]);
			
			for (; i < url.length; i++) {
				attr = { src: url[i] };
				match = url[i].match(urlRegExp);
				match && mimeTypes[match[1]] && (attr.type = mimeTypes[match[1]]);
				dom.create('source', attr, audio);
			}

			return audio;
		},
		
		// Methods
		
		// Remove the <audio> tag from the DOM tree
		release: function() {
			var audio = this._audio,
				parent = audio && audio.parentNode,
				c = this.constants.__values__;
				
			this._currentState = STOPPED;
			c.playing = c.paused = false;
			this._initialized = this._nextCmd = 0;
			if (parent) {
				event.off(this._handles);
				parent.removeChild(audio);
			}
			this._audio = 0;
		},
		
		pause: function() {
			this._nextCmd = this.pause;
			this._initialized && this._currentState === PLAYING && this._audio.pause();
		},
		
		start: function() {
			this._nextCmd = this.start;
			this._initialized && this._currentState !== PLAYING && this._audio.play();
		},
		
		play: function() {
			this.start();
		},
		
		_stop: function(description) {
			var a = this._audio;
				
			a.currentTime = 0;
			this._changeState(STOPPED, description || 'stopped');

			// Some versions of Webkit has a bug: if <audio>'s current time is non-zero and we try to 
			// stop it by setting time to 0 and pausing, it won't work: music is paused, but time is 
			// not reset. This is a work around.
			a.currentTime === 0 || a.load();
		},
		
		stop: function() {
			this._nextCmd = 0;
			if (!this._initialized) {
				return;
			}
				
			var a = this._audio;
			if (!a) {
				return;
			}
				
			if (this._currentState === PAUSED) {
				this._stop();
			} else {
				this._changeState(STOPPING, 'stopping');
				a.pause();
			}
		},
		
		isPaused: function() {
				return this.paused; 
		},
		
		isPlaying: function() {
				return this.playing;
		},
		
		stateDescription: function(stateId) {
			return stateMap[stateId] || '';
		},
		
		constants: {
			paused : false,
			playing : false,
			idle : false,
			state: STOPPED,
			progress: 0,
			STATE_BUFFERING:0,
			STATE_INITIALIZED:1,
			STATE_PAUSED:2,
			STATE_PLAYING:3,
			STATE_STARTING:4,
			STATE_STOPPED:5,
			STATE_STOPPING:6,
			STATE_WAITING_FOR_DATA:7,
			STATE_WAITING_FOR_QUEUE:8
		},
		
		properties: {
			url: {
				set: function(value, oldValue) {
					if (!value || value === oldValue) {
						return oldValue;
					}
					this.release();
					this._createAudio(value);
					return value;
				}
			},

			// The property 'volume' mirror (cache) the according property of the <audio> tag
			// Reason: if the <audio> tag is not initialized, direct referencing of the tag's properties
			// leads to exception. To prevent this situation, we mirror the property 'volume' and use this
			// if the tag's property cannot be accessed at the moment.

			volume: {
				value: 1.0,
				set: function(value) {
					value = Math.max(0, Math.min(1, value));
					this._initialized && (this._audio.volume = value);
					return value;
				}
			},
			
			// NOTE: This property is new. It is proposed for inclusion.
			autoplay: false
		}
	});
});