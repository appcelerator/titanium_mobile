/**
 * @overview
 * Library for controlling an Android Emulator.
 *
 * @module lib/emulator
 *
 * @copyright
 * Copyright (c) 2009-2013 by Appcelerator, Inc. All Rights Reserved.
 *
 * @license
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

var appc = require('node-appc'),
	__ = appc.i18n(__dirname).__,
	ADB = require('./adb'),
	async = require('async'),
	events = require('events'),
	fs = require('fs'),
	path = require('path'),
	util = require('util');

module.exports = EmulatorManager;

/**
 * Creates an Emulator instace.
 * @class
 * @extends EventEmitter
 * @classdesc Simple object that contains the avd settings and exposes event
 * methods.
 * @constructor
 */
function Emulator() {}
util.inherits(EmulatorManager.Emulator = Emulator, events.EventEmitter);

/**
 * Creates an EmulatorManager instance.
 * @class
 * @classdesc Manages emulator implementations and responsible for launching and
 * killing emulators.
 * @constructor
 * @param {Object} config - The CLI config object
 */
function EmulatorManager(config) {
	this.config = config;
}

/**
 * Loads emulator implementation modules and detects all available emulators.
 * @param {Object} [opts] - Detection options
 * @param {String} [opts.type] - The type of emulator to load (avd, genymotion); defaults to all
 * @param {Function} callback - A function to call when the detection has completed
 */
EmulatorManager.prototype.detect = function detect(opts, callback) {
	if (opts && typeof opts == 'function') {
		callback = opts;
		opts = {};
	}

	var files = opts && opts.type ? [ opts.type + '.js' ] : fs.readdirSync(path.join(__dirname, 'emulators')),
		re = /\.js$/,
		config = this.config;

	async.parallel(files.map(function (filename) {
		return function (next) {
			var file = path.join(__dirname, 'emulators', filename);
			if (re.test(filename) && fs.existsSync(file)) {
				var module = require(file);
				module.detect(config, opts, next);
			} else {
				next();
			}
		};
	}), function (err, results) {
		if (err) {
			callback(err);
		} else {
			var emus = [];
			results.forEach(function (r) {
				r && Array.isArray(r.avds) && (emus = emus.concat(r.avds));
			});
			callback(null, emus);
		}
	});
};

/**
 * Detects if a specific Android emulator is running.
 * @param {String} name - The name of the emulator
 * @param {Object} [opts] - Detection options
 * @param {String} [opts.type] - The type of emulator to load (avd, genymotion); defaults to all
 * @param {Function} callback - A function to call when the detection has completed
 */
EmulatorManager.prototype.isRunning = function isRunning(name, opts, callback) {
	if (opts && typeof opts == 'function') {
		callback = opts;
		opts = {};
	}

	this.detect(opts, function (err, emus) {
		if (err) return callback(err);

		var emu = emus.filter(function (e) {
			return e && e.name == name;
		}).shift();

		if (!emu) return callback(new Error(__('Invalid emulator "%s"', name)), null);

		// need to see if the emulator is running
		var adb = new ADB(this.config);
		adb.devices(function (err, devices) {
			if (err) return callback(err);

			// if there are no devices, then it can't possibly be running
			if (!devices.length) return callback(null, null);

			require(path.join(__dirname, 'emulators', emu.type + '.js')).isRunning(this.config, emu, devices, callback);
		}.bind(this));
	}.bind(this));
};

/**
 * Starts the specified emulator, if not already running.
 * @param {String} name - The name of the emulator
 * @param {Object} [opts] - Options for detection and launching the emulator
 * @param {Function} callback - A function to call when the emulator as launched
 */
EmulatorManager.prototype.start = function start(name, opts, callback) {
	if (opts && typeof opts == 'function') {
		callback = opts;
		opts = {};
	}

	this.isRunning(name, opts, function (err, running) {
		if (err) {
			// something went boom
			callback(err);
		} else if (running) {
			// already running
			callback(new Error(__('Emulator "%s" already running', name)), running);
		} else {
			this.detect(opts, function (err, emus) {
				// not running, start the emulator
				if (err) {
					callback(err);
				} else {
					var emu = emus.filter(function (e) {
						return e && e.name == name;
					}).shift();

					if (!emu) return callback(new Error(__('Invalid emulator "%s"', name)), null);

					var emulib = require(path.join(__dirname, 'emulators', emu.type + '.js'));
					emulib.start(this.config, emu, opts, function (err, emulator) {
						if (!err) {
							// we need to get the id of emulator
							var adb = new ADB(this.config),
								retryTimeout = 250, // if an adb call fails, how long before we retry
								bootTimeout = opts.bootTimeout || 60000, // 1 minute to boot before timeout
								// if a timeout is set and the emulator doesn't boot quick enough, fire the timeout event,
								// however if the timeout is zero, still listen for the timeout to kill the whilst loop above
								bootTimer = setTimeout(function () {
									bootTimeout && emulator.emit('timeout', { type: 'device', waited: bootTimeout });
									done = true;
								}, bootTimeout || 30000),
								sdcardTimeout = opts.sdcardTimeout || 60000, // 1 minute to boot before timeout
								sdcardTimer,
								done = false,
								runningInfo,
								deviceId;

							// keep polling the devices until the emulator we want is running
							async.whilst(
								function () { return !done; },
								function (cb) {
									if (!deviceId) {
										adb.devices(function (err, devices) {
											if (err || !devices.length) {
												setTimeout(cb, retryTimeout);
												return;
											}
											emulib.isRunning(this.config, emu, devices, function (err, running) {
												if (err) {
													// TODO: this could be bad... maybe we should emit an error event?
													done = true;
													return cb();
												} else if (!running) {
													// try again
													setTimeout(cb, retryTimeout);
												} else {
													// running!
													runningInfo = running;
													deviceId = running.device.id;
													cb();
												}
											});
										});
									} else {
										// emulator is running, now shell into it and check if it has booted
										adb.shell(deviceId, 'getprop init.svc.bootanim', function (err, output) {
											if (!err && output.toString().split('\n').shift().trim() == 'stopped') {
												clearTimeout(bootTimer);
												done = true;
												emulator.emit('booted', runningInfo.emu, runningInfo.device);
												return cb();
											}
											setTimeout(cb, retryTimeout);
										});
									}
								}.bind(this),
								function () {} // do nothing
							);

							emulator.on('booted', function () {
								var done = false;
								// keep polling /sdcard until it's mounted
								async.whilst(
									function () { return !done; },
									function (cb) {
										// emulator is running, now shell into it and check if it has booted
										adb.shell(deviceId, 'cd /sdcard && echo "SDCARD READY"', function (err, output) {
											if (!err && output.toString().split('\n').shift().trim() == 'SDCARD READY') {
												clearTimeout(sdcardTimer);
												done = true;
												emulator.emit('ready', runningInfo.emu, runningInfo.device);
												return cb();
											}
											setTimeout(cb, retryTimeout);
										});
									}.bind(this),
									function () {} // do nothing
								);

								sdcardTimer = setTimeout(function () {
									sdcardTimeout && emulator.emit('timeout', { type: 'sdcard', waited: sdcardTimeout });
									done = true;
								}, sdcardTimeout || 30000);
							});
						}

						callback(err, emulator);
					}.bind(this));
				}
			}.bind(this));
		}
	}.bind(this));
};

/**
 * Stops the specified emulator, if running.
 * @param {String} name - The name of the emulator
 * @param {Object} [opts] - Options for detection and killing the emulator
 * @param {Function} callback - A function to call when the emulator as been killed
 */
EmulatorManager.prototype.stop = function stop(name, opts, callback) {
	if (opts && typeof opts == 'function') {
		callback = opts;
		opts = {};
	}

	this.isRunning(name, opts, function (err, running) {
		if (err) {
			// something went boom
			callback(err);
		} else if (!running) {
			// already stopped
			callback(new Error(__('Emulator "%s" not running', name)));
		} else {
			require(path.join(__dirname, 'emulators', running.emu.type + '.js')).stop(this.config, name, running.device, opts, callback);
		}
	}.bind(this));
};
